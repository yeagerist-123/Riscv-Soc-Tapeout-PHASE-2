# Caravel RTL & GLS Verification — Environment Setup

This README explains how to prepare a complete development environment for Caravel RTL verification and gate-level (GLS) verification on the SKY130 process. It collects the essential steps (cloning the repo, installing the PDK, verifying toolchains) and provides practical tips and troubleshooting notes so you can get simulations running quickly.

What I did: I collected and organized the steps you provided into a structured README with commands, environment hints, and troubleshooting. What’s next: follow the steps below in your shell and then use your repo's DV / simulation targets (or ask me to add run scripts or simulation examples).

---

## Table of Contents

- Overview
- Prerequisites
- 1. Clone the Caravel repository
- 2. Install SKY130 PDK (three methods)
- 3. Verify required tools
- 4. Running simple RTL simulations (examples)
- 5. Gate-level simulation (GLS) notes
- Troubleshooting
- References & Contacts

---

## Overview

This document focuses on setting up a reproducible environment to run:
- RTL functional simulation (Icarus Verilog / Verilator)
- Gate-level simulation (GLS) — functional or timing-annotated (notes below)

It assumes you are working on a Unix-like system (Linux/macOS) with Python and pip available.

---

## Prerequisites

Install standard developer tools if not present:
- git
- python3 and pip
- make
- build tools (gcc, g++, make)
- nproc/tooling for parallel builds

You may also use Docker for reproducible environments (not covered here).

---

## 1. Clone the Official Caravel Repository

Clone the repo and enter it:

```bash
git clone https://github.com/efabless/caravel
cd caravel
```

You should see the top-level structure:

caravel/
 ├── rtl/
 ├── verilog/
 ├── openlane/
 ├── dv/
 └── Makefile

---

## 2. Install the SKY130 PDK

There are three common ways to get the SKY130 PDK. The recommended modern way is Volare.

Method 1 — Install SKY130 PDK using Volare (Recommended)

```bash
pip install volare
# list available builds
volare ls-remote
# enable a platform version (example: latest sky130A)
volare enable -p sky130A -v latest
# confirm installations
volare ls
```

Typical PDK location after enabling:
`~/.volare/sky130A/<version>/`
better use 0fe599b2afb6708d281543108caf8310912f54af version.


Export PDK_ROOT (add to ~/.bashrc or ~/.profile for persistence):

```bash
export PDK_ROOT="$HOME/.volare"
```

Method 2 — Install SKY130 PDK via OpenLane (Automatic)

If you prefer OpenLane's automated install:

```bash
cd openlane
make pdk
```

This installs open_pdks and the SKY130A PDK used by OpenLane.

Method 3 — Manual open_pdks source build

```bash
git clone https://github.com/RTimothyEdwards/open_pdks
cd open_pdks
./configure --enable-sky130-pdk
make -j$(nproc)
sudo make install
```

Note: manual builds can be slower and require additional dependencies. Volare produces verified reproducible builds and is recommended.

---

## 3. Verify Required Tools

Confirm the simulators and compilers you plan to use are installed and on PATH.

Icarus Verilog (iverilog & vvp):

```bash
iverilog -V
vvp -V
```

Verilator:

```bash
verilator --version
```

Other useful tools:
- yosys (synthesis)
- openlane / openroad (for P&R and netlist generation)
- magic, netgen (DRC/LVS; part of the PDK toolchain)
- make (to run provided Makefile targets)

Install via package manager or build from source if missing.

---

## 4. Running Simple RTL Simulations

Functional RTL simulation with Icarus Verilog (example):

1. Identify the top-level testbench and sources within `dv/` or `rtl/`.
2. Compile:

```bash
# example names - replace with actual testbench and sources
iverilog -g2012 -o simv work_tb.sv rtl/*.sv verilog/*.v
```

3. Run:

```bash
vvp simv
```

Verilator (cycle-accurate, C++ simulation):

```bash
# example usage (replace top module name and sources)
verilator --cc --build -Wno-fatal --exe --top-module top_module rtl/top_module.sv dv/testbench.cpp
./obj_dir/Vtop_module
```

Refer to your repository's `dv/` folder for specific testbench scripts and Makefile targets that automate these steps.

---

## 5. Gate-Level Simulation (GLS) — Notes & Guidance

Gate-level simulation typically uses a synthesized netlist (post-synthesis or post-P&R). There are two common modes:

- Functional GLS (no timing back-annotation): Use the gate-level Verilog netlist generated by Yosys/OpenLane and simulate with Icarus Verilog or Verilator. This verifies logic equivalence at gate-level but not timing.
- Timing-annotated GLS (SDF back-annotation): Requires an SDF file and a simulator that supports SDF back-annotation (commercial simulators like Synopsys VCS, Cadence Xcelium, Mentor/Siemens Questa/ModelSim). Icarus Verilog and Verilator have limited or no SDF back-annotation support.

---

## Troubleshooting

- PDK_ROOT not set / permission errors:
  - Ensure `PDK_ROOT` points to the directory containing the PDK installs (e.g. `~/.volare`).
  - Add `export PDK_ROOT=~/.volare` to `~/.bashrc`.
- Volare fails to install:
  - Update pip and setuptools, run `pip install --upgrade pip setuptools wheel`.
- OpenLane `make pdk` fails:
  - Check for missing dependencies (Docker, Python packages) and network access.
- Icarus/Verilator missing:
  - Install via your package manager (apt, brew) or build from source.
- SDF/Timing-annotated gates:
  - If you require SDF timing, use a commercial simulator (VCS, Xcelium, Questa). Open-source tools currently have limited SDF support.

---

## References & Contacts

- Caravel repo: https://github.com/efabless/caravel
- Volare: https://github.com/efabless/volare
- OpenLane: https://github.com/The-OpenROAD-Project/OpenLane
- open_pdks: https://github.com/RTimothyEdwards/open_pdks
- SKY130 PDK documentation in PDK tree

---
# TASK_2 hkspi DV Test 

This documents the housekeeping SPI (hkspi) directed verification (DV) test for the Caravel SoC. It describes the test files, I/O behavior, register expectations, the test flow and concise instructions for running RTL and gate-level (GLS) simulations.

Location
- Test directory:
  - caravel/verilog/dv/caravel/mgmt_soc/hkspi

Key Files
- verilog/dv/caravel/mgmt_soc/hkspi/hkspi_tb.v
  - Testbench that models an external SPI master.
  - Drives CSB (active-low), SCK, SDI and samples SDO.
  - Loads the SPI command stream from hkspi.hex via $readmemh.
  - Compares observed SDO data against expected values and reports PASS/FAIL.

- verilog/rtl/housekeeping_spi.v
  - The RTL implementation of the Housekeeping SPI controller.
  - Decodes SPI commands and issues Wishbone read/write transactions.
  - Provides register access (ID, config, GPIO mode/direction, LA, etc.).
  - Shifts readback data out on SDO.

- verilog/dv/caravel/mgmt_soc/hkspi/hkspi.hex
  - Hex file containing the test command/data stream.
  - Encodes reads, writes and expected readback patterns used by the testbench.

Overview / Purpose
The hkspi DV test validates the SPI-to-Wishbone bridge functionality by driving an SPI master model and comparing returned SDO bitstreams against expected responses encoded in hkspi.hex. The test is used to ensure the housekeeping SPI behaves identically in RTL and gate-level simulations and that internal register accesses are correct.

I/O Behavior (Signals)
- CSB (input) — active-low chip select.
- SCK (input) — serial clock from the SPI master.
- SDI (input) — serial data in (Master → hkspi).
- SDO (output) — serial data out (hkspi → Master).

Register Accessed by hkspi (typical)
- Chip ID / identification registers
- System configuration registers
- GPIO mode and direction registers
- Logic Analyzer (LA) enable/configuration
- Wishbone control/status registers
These registers are readable and writable via SPI commands encoded in hkspi.hex.

Test Flow (high-level)
1. Testbench reset and initialization.
2. $readmemh("hkspi.hex", ...) loads the SPI command stream.
3. The tb drives CSB/SCK/SDI to emulate transactions (reads/writes).
4. housekeeping_spi decodes commands and does Wishbone accesses.
5. Read data is shifted out on SDO; the TB captures SDO and compares against expected patterns from hkspi.hex.
6. TB reports PASS if all observed patterns match expectations, otherwise FAIL.

Running RTL Simulation (Icarus Verilog)
- Compile (example; adjust file lists/names to match repository):
  iverilog -g2012 -o hkspi_sim \
    verilog/rtl/housekeeping_spi.v \
    verilog/dv/caravel/mgmt_soc/hkspi/hkspi_tb.v \
    # add other required rtl files if the module has dependencies

- Run:
  vvp hkspi_sim
- The testbench prints PASS/FAIL and any mismatch information.

Running with Verilator (C++ simulation)
- Example flow (adapt file/module names and TB harness):
  verilator --cc --build --top-module hkspi_tb \
    --exe verilog/dv/caravel/mgmt_soc/hkspi/hkspi_tb.cpp \
    verilog/rtl/housekeeping_spi.v \
    # add other source files as needed

- Run the produced executable (e.g., ./obj_dir/Vhkspi_tb)

Gate-Level Simulation (GLS) Notes
- Functional GLS:
  - Use a synthesized/gate-level Verilog netlist (from Yosys/OpenLane) in place of the RTL module.
  - Run the same TB to compare functional behavior between RTL and GLS.
- Timing-annotated GLS (SDF):
  - SDF back-annotation requires a simulator with SDF support (commercial tools: VCS, Xcelium, Questa).
  - Icarus Verilog/Verilator have limited or no SDF back-annotation support — for full timing checks use a commercial simulator.
- Typical flow:
  1. Generate gate-level netlist via your synthesis/OpenLane flow.
  2. Replace RTL module with gate-level netlist in the testbench compile.
  3. Run the TB and compare results. If mismatches occur, inspect timing/clocking and synthesis constraints.

Where Expected Patterns Come From
- hkspi.hex contains both the commands to send and the expected readback values; the TB reads it and uses the same file to validate SDO outputs. To change test vectors, edit hkspi.hex and re-run.

How hkspi Interacts with the Management SoC and User Project (One-page summary)
- The housekeeping SPI (hkspi) is the SPI-to-Wishbone bridge inside the management SoC.
- External SPI Master → hkspi decodes commands → issues Wishbone transactions.
- Registers accessible via hkspi include chip ID, configuration, GPIO modes/directions, LA enables, and Wishbone-mapped user registers.
- hkspi configures GPIOs and LA probes that can affect or observe the user project; it can also access user-exposed registers on the Wishbone bus.
- This makes hkspi critical for pre-silicon DV, bring-up, and post-s

- # TASK-3 HKSPI RTL Simulation (DV)

This document describes how to run the RTL simulation for the housekeeping SPI (hkspi) DV testbench and how to save the output for later comparison with GLS results.

Prerequisites
- Icarus Verilog (iverilog) installed
- make available in your environment
- You are in the repository root or can change into the DV directory below

Steps

1. Change into the hkspi DV directory:
   ```
   cd caravel/verilog/dv/caravel/mgmt_soc/hkspi
   ```

2. Run the RTL simulation using Make:
   ```
   make sim=rtl
   ```
   This will:
   - compile all required RTL files
   - build the hkspi testbench
   - run the simulation with Icarus Verilog
   - print the test monitor output to the console

3. Confirm successful simulation output:
   - A successful RTL simulation must end with the following line:
     ```
     Monitor: Test HK SPI (RTL) Passed
     ```
   - If this line is missing or shows `Failed`, the RTL logic needs debugging.

4. Save the RTL simulation log:
   ```
   make sim=rtl | tee rtl_hkspi.log
   ```
<img width="1920" height="923" alt="t10-1" src="https://github.com/user-attachments/assets/fc324973-b541-4236-8502-164cc2dcfdcd" />

   
   - The file `rtl_hkspi.log` will contain the full simulator output and is used later for comparison with GLS results.

Troubleshooting
- If the simulation fails to start, verify iverilog is in PATH and that dependencies are present.
- If tests run but final monitor shows `Failed`, inspect the log (`rtl_hkspi.log`) for assertions, mismatches, or monitor messages to trace the failing behavior.

Summary
- Run: `make sim=rtl`
- Verify final line: `Monitor: Test HK SPI (RTL) Passed`
- Save log: `make sim=rtl | tee rtl_hkspi.log`


# TASK-4 HKSPI DV - RTL Simulation and GLS Netlist

This document describes how to run the RTL simulation for the housekeeping SPI (hkspi) DV testbench, how to save the RTL output for later comparison with GLS results, and how to generate the gate-level netlist used for GLS.

Prerequisites
- Icarus Verilog (iverilog) installed
- OpenLane / Yosys (for synthesis) available in the environment for GLS generation
- make available in your environment
- You are in the repository root or can change into the DV directory below

1. Change into the hkspi DV directory:
```
cd caravel/verilog/dv/caravel/mgmt_soc/hkspi
```

2. Run the RTL simulation using Make:
```
make sim=rtl
```
This will:
- compile all required RTL files
- build the hkspi testbench
- run the simulation with Icarus Verilog
- print the test monitor output to the console

3. Confirm successful simulation output:
- A successful RTL simulation must end with the following line:
```
Monitor: Test HK SPI (RTL) Passed
```
- If this line is missing or shows `Failed`, the RTL logic needs debugging.

4. Save the RTL simulation log:
```
make sim=rtl | tee rtl_hkspi.log
```
- The file `rtl_hkspi.log` will contain the full simulator output and is used later for comparison with GLS results.

  <img width="1920" height="1080" alt="rtllog" src="https://github.com/user-attachments/assets/4ebfc8da-bbbe-4087-ade6-03010f16bfb5" />


Troubleshooting (RTL)
- If the simulation fails to start, verify iverilog is in PATH and that dependencies are present.
- If tests run but final monitor shows `Failed`, inspect the log (`rtl_hkspi.log`) for assertions, mismatches, or monitor messages to trace the failing behavior.

4. Generate Gate-Level Netlist (GLS)

The gate-level netlist is required for running GLS (Gate-Level Simulation) of the hkspi test. Caravel provides a built-in make target that performs synthesis and prepares GLS files automatically.

4.a Run Synthesis + GLS Netlist Generation

From the hkspi test directory:
```
cd caravel/verilog/dv/caravel/mgmt_soc/hkspi
```

Run the GLS build:
```
make SIM=GLS
```

This command:
- Invokes OpenLane/Yosys synthesis for the Caravel top-level
- Automatically generates all gate-level netlists
- Places synthesized files inside `verilog/gl/`
- Prepares the GLS testbench environment

Note: Ensure OpenLane and its toolchain are installed and configured in your environment before running `make SIM=GLS`. The synthesis step can be long and may require significant disk space and tool dependencies.

4.b Locate the Generated Gate-Level Netlist

After `make SIM=GLS` completes, the GLS netlist files will be available in:
```
caravel/verilog/gl/
```

Important synthesized modules (examples) include:
- caravel.v
- mgmt_core.v
- housekeeping_spi.v
- other auto-generated GL modules

These generated files are the ones used in GLS for hkspi.

Troubleshooting (GLS)
- If synthesis fails, check the OpenLane/Yosys logs printed during `make SIM=GLS` for errors, missing cells, or SDC/constraints issues.
- Verify PDK/toolchain availability and correct PATH settings for OpenLane.
- If netlists are generated but GLS fails, compare the GLS simulator messages against the RTL log (`rtl_hkspi.log`) to identify mismatches or timing-related failures.

Summary
- RTL run: `make sim=rtl` — verify `Monitor: Test HK SPI (RTL) Passed`
- Save RTL log: `make sim=rtl | tee rtl_hkspi.log`
- Generate GL netlists: `make SIM=GLS`
- GL netlists located: `caravel/verilog/gl/`

# TASK-5 GLS Execution

This document covers GLS execution , how to confirm correct GLS output, and how to save the GLS log.

5.b GLS Execution with Timing Annotation
- The standard make target includes timing and primitive models:
  - Gate delays (from synthesized netlists)
  - Wire delays (if available from the flow)
  - Sky130 primitive models
  - SDF timing annotation (automatically applied when SDF files are present)
- To run the GLS flow via Make (recommended):
  ```
  make SIM=GLS
  ```
<img width="1920" height="1080" alt="t10-2" src="https://github.com/user-attachments/assets/18d46d9f-b8b1-4f36-9331-a78dbc9405e8" />

  
- Optional manual execution after synthesis (confirm the produced VVP filename in the GLS output directory):
  ```
  vvp gls_hkspi.vvp
  ```

5.c Confirm Correct GLS Output
- A successful GLS run must end with the exact line:
  ```
  Monitor: Test HK SPI (GL) Passed
  ```
- If the final monitor shows `Failed` or you observe mismatched monitor output, halt and debug before proceeding. Compare GLS behavior/logs against the RTL log (`rtl_hkspi.log`) to locate functional mismatches or timing-induced failures.

5.d Save the GLS Log
- Capture and save the full GLS output for documentation and RTL/GLS comparison:
  ```
  make SIM=GLS | tee gls_hkspi.log
  ```
  or, if running the VVP manually:
  ```
  vvp gls_hkspi.vvp | tee gls_hkspi.log
  ```
<img width="1920" height="1080" alt="glslog" src="https://github.com/user-attachments/assets/86a38a4e-56ed-46b2-927e-a4dce299ff2d" />

  
- The saved `gls_hkspi.log` is required for:
  - Documentation
  - Comparison with `rtl_hkspi.log`
  - Verification deliverables

Troubleshooting tips
- If SDF is not applied, check that SDF files exist and the testbench references them correctly.
- If GLS fails due to missing primitives or models, ensure Sky130 primitive models and PDK runtime files are available in the environment.
- Confirm synthesized netlists are present in `caravel/verilog/gl/` and that you run GLS from the hkspi DV directory or otherwise point to the correct files.
- For timing-related mismatches, compare monitor traces and consider re-running synthesis with adjusted constraints or checking SDC inputs.


# TASK-6. Compare RTL vs GLS Results

This document describes how to compare textual monitor output and waveforms between RTL and GLS runs for the hkspi test.

Prerequisites
- You have saved the RTL and GLS logs:
  - rtl_hkspi.log
  - gls_hkspi.log
- RTL and GLS VCDs (or GTKW savefiles) were enabled/generated by the Makefile:
  - rtl.vcd / rtl.gtkw
  - gls.vcd / gls.gtkw

6.a Compare Text Output (Monitor + Register Reads)

 Compare them:
   ```
   diff -u rtl_log.txt gls_log.txt
   ```
<img width="1920" height="1080" alt="logcomp" src="https://github.com/user-attachments/assets/92a1ffef-35f5-4474-969a-aac3888bd3a2" />


   - A correct design shows no differences.
   - If diff reports differences, inspect the surrounding log lines to locate mismatches (register reads, status prints, or timing-related message differences).

Notes:
- When comparing, pay attention to register readback values and any timestamp/cycle numbers that may differ in formatting — focus on the functional data (read values, pass/fail messages).
- If monitor messages differ only in whitespace/timestamps, strip those fields before diffing (e.g., use awk/sed) to compare semantic content.

6.b Compare Waveforms Using GTKWave
1. Open RTL waveform:
   ```
   gtkwave hkspi.vcd
   ```
![rtlwave](https://github.com/user-attachments/assets/7d14e15b-cae6-40df-b2c5-8b5c7ff763b0)

   
2. Open GLS waveform:
   ```
   gtkwave hkspi.vcd  (after finising gls)
   ```
![glswave](https://github.com/user-attachments/assets/02c78ac1-9c8e-4c25-a335-8395c97e9416)


  

Signals to focus on
- csb (chip select)
- sck (SPI clock)
- sd_i (SPI input)
- sd_o (SPI output)
- Register readback signals inside `housekeeping_spi`
- Wishbone signals (optional / as needed for debugging)

Comparison approaches
- View RTL and GLS waveforms side-by-side in separate GTKWave windows.
- Alternatively, open/save a gtkw savefile for one run and load the other VCD into the same gtkw session (or use savefile overlays) to align and compare signals.
- Zoom on SPI transfers and register-read cycles to verify bit-level timing.

Expected observations (what to check)
- Clock edges align.
- Data bits shift on the same cycles.
- sd_o (SPI output) sequences match bit-for-bit.
- Register read values match exactly between RTL and GLS.
- No extra 'x' or 'z' states introduced in GLS.
- Resets and control signals behave identically.

6.c Verify Exact Match (Pass Criteria)
- Every register read in GLS equals the identical read in RTL.
- Every waveform transition matches cycle-by-cycle for the observed signals.
- SPI output (sd_o) matches bit-by-bit across the entire transaction sequence.
- The GLS monitor prints the pass message:
  ```
  Monitor: Test HK SPI (GL) Passed.
  ```

If mismatches are found
- First compare the textual monitor outputs to find which register read or transaction differs.
- Use GTKWave to inspect the first differing cycle and determine whether the cause is:
  - Functional mismatch introduced by synthesis (rare), or
  - Timing/SDF back-annotation causing different behavior (eg. setup/hold violations producing different samples), or
  - Missing/incorrect primitive models or netlist connections.
- Re-run the failing case with additional waveform dump points (enable more internal signals) or add debug monitor prints in the testbench to capture internal state.
- Check SDF annotation: ensure SDF files were applied and paths referenced correctly in the GLS testbench.

# Problems Faced During RTL & GLS Verification

During setup and simulation, several common issues can occur. The checklist below summarizes problems encountered and their solutions.

## 1. Incorrect File or Directory Paths

Many GLS/RTL failures occur because the paths inside the Makefile or testbench are incorrect.

Symptoms
- "file not found" errors
- Missing modules during compilation
- Undefined references to RTL or GLS files

Solution
- Double-check all relative paths (../../../).
- Ensure DV, RTL, and GL directories are correctly referenced.
- Verify the repository folder structure has not been modified.

Tip: Print the working directory and key paths inside your Makefile/testbench to verify they resolve as expected.

---

## 2. Icarus Verilog Version Must Be 11 (Very Important)

Caravel requires Icarus Verilog version 11 for GLS and certain DV tests.

Using version 10 or older can cause:
- Incorrect signal propagation
- Random X values in GLS
- Strange parsing errors
- Simulation crashes

Check your version:
```bash
iverilog -V
```

If not version 11, upgrade. Example (OS package manager may vary):
```bash
sudo apt-get remove iverilog
sudo apt-get install iverilog
```

Or build from source:
```bash
git clone https://github.com/steveicarus/iverilog
cd iverilog
sh autoconf.sh
./configure
make -j4
sudo make install
```

---

## 3. caravel_pico Repository Must Be Cloned

Some simulations require mgmt_core_wrapper.v, which is not present in the main Caravel repo. This file exists in:
- caravel_pico/

Without it, you may see errors such as:
- mgmt_core_wrapper.v: No such file
- Undefined module: mgmt_core_wrapper
- Missing management SoC sources

Solution
```bash
git clone https://github.com/efabless/caravel_pico
```
Then add the correct include path in your Makefile or simulation command.

⚠️ Be very careful with paths. Most issues arise due to mistakes in relative path references.

---

## 4. Allocate at Least 100 GB to the VM

OpenLane + PDK + Caravel requires a large amount of storage.

Symptoms of low disk space
- Synthesis stopping midway
- PDK installation failing
- "No space left on device" errors

Solution
- Ensure your VM storage is:
  - Minimum: 100 GB

---

## Quick Troubleshooting Checklist

- [ ] Verify Makefile/testbench paths (print and inspect resolved paths).
- [ ] Confirm iverilog -V shows version 11.
- [ ] Ensure caravel_pico is cloned and include paths updated.
- [ ] Confirm VM/disk size >= 100 GB and available free space for synthesis.
- [ ] If errors persist, capture full logs:
  - RTL: `make sim=rtl | tee rtl_hkspi.log`
  - GLS: `make SIM=GLS | tee gls_hkspi.log`
  Inspect logs for "file not found", missing module names, or parsing errors and trace back to path or toolchain issues
